<page-flow-view>
  <div class="d-block w-100">

    <div class="flow-container" ref="flow-container">
      <div class="flow-inner" style={ props.zoom ? `zoom : ${props.zoom}` : '' }>
        <!-- trigger -->

        <div class="card card-flowing card-trigger mb-4">
          <div class="card-header">
            <div class="card-icon">
              <i class="fa fa-bolt" />
            </div>
            Trigger
          </div>
          <div class="card-body">
            <span>
              On
            </span>
            <eden-select class="d-inline-flex mx-1" on-change={ (e, value) => onTrigger(value) } placeholder="Select Trigger" data={ getTriggerData() } />
            <dashup-view if={ props.page.get('data.trigger.type') } type="trigger" view="config" struct={ props.page.get('data.trigger.type') } set={ (k, v) => onSetTrigger(k, v) } get-trigger={ (t) => getTrigger(t) } props={ (k, v) => setProps(k, v) } page={ props.page } dashup={ props.dashup } actions={ props.actions } triggers={ props.triggers } { ...(state.extraProps) } />
          </div>
        </div>
        
        <page-flow-section if={ !loading('refresh') } children={ props.page.get('data.children') || [] } data-id="root" get-action={ (a) => getAction(a) } props={ (k, v) => setProps(k, v) } page={ props.page } dashup={ props.dashup } on-set={ onSetChild } actions={ props.actions } triggers={ props.triggers } on-sidebar={ onSidebar } { ...(state.extraProps) } />
      </div>

      <page-flow-sidebar ref={ ref('sidebar') } loading={ loading } page={ props.page } dashup={ props.dashup } on-set={ onSetChild } actions={ props.actions } triggers={ props.triggers } { ...(state.extraProps) } />
    </div>

  </div>

  <script>
    // import base
    import { v4 } from 'uuid';
    import dotProp from 'dot-prop';
    import Sortable from 'sortablejs';

    // import sidebar
    import pageFlowSection from './section';
    import pageFlowSidebar from './sidebar';

    // register
    riot.register('page-flow-section', pageFlowSection);

    /**
     * export default flow update
     */
    export default class DashupFlowPage {

      // ////////////////////////////////////////////////////////////////////////////
      //
      // RIOT METHODS
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
       * components
       */
      static get components() {
        // return
        return {
          pageFlowSidebar,
          pageFlowSection,
        };
      }

      /**
       * on before mount
       */
      onBeforeMount(...args) {
        // bind methods
        this.ref      = this.ref.bind(this);
        this.loading  = this.loading.bind(this);
        this.initSort = this.initSort.bind(this);

        // bind event methods
        this.setProps     = this.setProps.bind(this);
        this.onSidebar    = this.onSidebar.bind(this);
        this.onTrigger    = this.onTrigger.bind(this);
        this.onSetChild   = this.onSetChild.bind(this);
        this.onSetTrigger = this.onSetTrigger.bind(this);
        this.onMouseMoved = this.onMouseMoved.bind(this);

        // get methods
        this.getAction  = this.getAction.bind(this);
        this.getTrigger = this.getTrigger.bind(this);

        // updated
        this.safeUpdated = () => this.update();

        // listeners
        this.props.page.on('data.trigger', this.safeUpdated);
      }

      /**
       * on mounted
       */
      onMounted(...args) {
        // check frontend
        if (typeof window === 'undefined') return; 

        // set flow tree
        if (!this.props.page.get('data.render')) {
          // set flow tree
          this.props.page.set('data.render', {});
        }

        // init sort
        this.initSort();
      }

      /**
       * on updated
       */
      onUpdated(...args) {
        // check frontend
        if (typeof window === 'undefined') return; 

        // init sort
        this.initSort();
      }

      /**
       * on before mount
       */
      onBeforeUnmount(...args) {
        // check frontend
        if (typeof window === 'undefined') return; 

        // listeners
        this.props.page.removeListener('data.trigger', this.safeUpdated);
      }


      // ////////////////////////////////////////////////////////////////////////////
      //
      // GET METHODS
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
       * gets action
       */
      getAction(action = {}) {
        // get trigger
        const actualAction = (this.props.actions || []).find((a) => a.type === action.type);

        // return actual trigger
        return actualAction;
      }

      /**
       * gets trigger
       */
      getTrigger(trigger = {}) {
        // get trigger
        const actualTrigger = (this.props.triggers || []).find((t) => t.type === trigger.type);

        // return actual trigger
        return actualTrigger;
      }

      /**
       * get value
       */
      getTriggerData() {
        // return triggers
        return this.props.triggers.map((trigger) => {
          // return object
          return {
            name     : trigger.title,
            value    : trigger.type,
            selected : this.props.page.get('data.trigger.type') === trigger.type,
          };
        });
      }

      /**
       * get trigger view
       */
      getTriggerView() {
        // get trigger
        const actualTrigger = this.getTrigger(this.props.page.get('data.trigger') || {});

        // view
        if (!actualTrigger) return;

        // return trigger view
        return `trigger-${actualTrigger.view || this.props.page.get('data.trigger.type')}-config`;
      }


      // ////////////////////////////////////////////////////////////////////////////
      //
      // ACTION METHODS
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
       * on update
       *
       * @param {String} key
       * @param {*} values
       */
      setProps(key, value) {
        // extra props
        const extraProps = this.state.extraProps || {};

        // set
        dotProp.set(extraProps, key, value);

        // update
        this.update({
          extraProps,
        });
      }


      // ////////////////////////////////////////////////////////////////////////////
      //
      // EVENT METHODS
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
       * on mouse moved
       *
       * @param {Event} e
       */
      onMouseMoved (e) {
        // check dragging
        if (!this.dragging) return;

        // width
        const maxTop = jQuery(window).height() / 2;
        const maxLeft = jQuery(window).width() - jQuery('.eden-blocks-sidebar').width();

        // out
        const out = { x : 0, y : 0 };

        // type
        if (e.type == 'touchstart' || e.type == 'touchmove' || e.type == 'touchend' || e.type == 'touchcancel') {
          const touch = e.originalEvent.touches[0] || e.originalEvent.changedTouches[0];
          out.x = touch.pageX;
          out.y = touch.pageY;
        } else if (e.type === 'drag' || e.type == 'mousedown' || e.type == 'mouseup' || e.type == 'mousemove' || e.type == 'mouseover'|| e.type == 'mouseout' || e.type == 'mouseenter' || e.type == 'mouseleave') {
          out.x = e.pageX;
          out.y = e.pageY;
        }

        // showing
        if (out.x > maxLeft && !this.refs.sidebar.state.showing && this.dragging) {
          // show
          this.refs.sidebar.show();
        } else if (out.x < maxLeft && this.refs.sidebar.state.showing && this.dragging) {
          // hide
          this.refs.sidebar.hide();
        }
      }

      /**
       * on child set
       */
      async onSetChild(child, key, value) {
        // check key
        if (typeof key === 'object') {
          // check keys
          Object.keys(key).forEach((k) => {
            // set value
            child[k] = key[k];
          });
        } else {
          // set in child
          child[key] = value;
        }

        // on data
        await this.props.data('children', this.props.page.get('data.children'));
      }

      /**
       * on model
       */
      async onTrigger(trigger) {
        // get value
        if (!trigger) trigger = this.refs.trigger.val();

        // model
        if (!trigger || !trigger.length) return;
        
        // set model
        await this.props.data('trigger.type', trigger);

        // update view
        this.update();
      }

      /**
       * on set trigger
       */
      onSetTrigger(k, v) {
        // set value
        return this.props.data(`trigger.${k}`, v);
      }

      /**
       * on sidebar
       */
      onSidebar(e) {
        // check event
        if (e) {
          e.preventDefault();
          e.stopPropagation();
        }

        // show sidebar
        this.refs.sidebar.show();
      }


      // ////////////////////////////////////////////////////////////////////////////
      //
      // INIT METHODS
      //
      // ////////////////////////////////////////////////////////////////////////////
        
      /**
       * init sort
       */
      initSort () {
        // sortables
        if (this.sortables) {
          // try/catch
          try {
            // destroy
            this.sortables.forEach((sortable) => sortable.destroy());
          } catch (e) {}
        }

        // sortables
        this.sortables = [];

        // check init
        if (!this.$$('.flow-elements').length) return;

        console.log(Sortable);

        // create sortables
        this.$$('.flow-elements-row, .builder-elements').forEach((item) => {
          // push
          this.sortables.push(new Sortable(item, {
            group          : 'flow-elements',
            handle         : '.card-flow, .card-header.drag',
            draggable      : '.card-flow, [id]',
            animation      : 200,
            fallbackOnBody : true,

            onStart : (e) => {
              // add class
              this.dragging = true;

              // add listener
              $(document).on('drag', this.onMouseMoved);
              $(document).on('touchmove', this.onMouseMoved);
              $(document).on('mousemove', this.onMouseMoved);
            },

            onEnd : async (e) => {
              // add class
              this.dragging = false;

              // add listener
              $(document).off('drag', this.onMouseMoved);
              $(document).off('touchmove', this.onMouseMoved);
              $(document).off('mousemove', this.onMouseMoved);

              // set item
              const el     = e.item;
              const target = e.to;
              const source = e.from;
              const parent = $(target).closest('page-flow-section').attr('data-id');

              // children
              let children = this.props.page.get('data.children') || [];

              // get parent
              let id      = el.getAttribute('id');
              let element = children.find((em) => em.uuid === id);

              // removed
              if (element && target.getAttribute('class').includes('builder-elements')) {
                // filter children
                children = children.filter((child) => {
                  // return remove
                  return child.uuid !== element.uuid;
                });

                // loading
                this.loading('refresh', true);

                // on data
                await this.props.data('children', children);

                // loading
                this.loading('refresh', false);

                // refresh
                return;
              }

              // loop physical fields
              target.childNodes.forEach((f, i) => {
                // check placement
                if (!f.getAttribute) return;

                // get parent
                id      = f.getAttribute('id');
                element = children.find((em) => em.uuid === id);

                // check id
                if (!id) {
                  // action
                  const action = this.props.actions.find((t) => t.type === f.getAttribute('type'));

                  // element
                  element = {
                    type : action.type,
                    uuid : v4(),
                  };

                  // push
                  children.push(element);
                }

                // set parent
                element.order  = i;
                element.parent = parent;
              });

              // loading
              this.loading('refresh', true);

              // on data
              await this.props.data('children', children);

              // refresh
              this.loading('refresh', false);
            }
          }));
        });
      }

      /**
       * ref
       */
      ref(name) {
        // set refs
        if (!this.refs) this.refs = {};

        // return ref function
        return (that) => {
          // set ref
          this.refs[name] = that;
        };
      }

      /**
       * set loading
       */
      loading(type, way) {
        // set loading
        if (!this.__loading) this.__loading = new Map();

        // check loading
        if (!type) return !!Array.from(this.__loading.values()).find((v) => v);
        if (typeof way === 'undefined') return !!this.__loading.get(type);

        // set loading
        this.__loading.set(type, way);
        this.update();
      }
    }
  </script>
</page-flow-view>